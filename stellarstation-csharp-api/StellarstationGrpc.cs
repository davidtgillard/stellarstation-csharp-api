// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: stellarstation/api/v1/stellarstation.proto
// </auto-generated>
// Original file comments:
//
// Copyright 2019 Infostellar, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Stellarstation.Api.V1 {
  /// <summary>
  /// The public API service of StellarStation, a system supporting communication between satellites
  /// and ground stations. This API is for use by an operator of a satellite - it is invalid to specify
  /// satellites that the operator does not own or plans they have not reserved.
  /// Only using IDs shown on the StellarStation Console or returned in API responses will ensure all
  /// inputs are valid.
  ///
  /// A pass is a time range where an ground station and satellite can communicate with each other, i.e.,
  /// the period between Acquisition of Signal (AOS) and Loss of Signal (LOS) of the ground station and
  /// satellite pair.
  ///
  /// A plan is a scheduled pass that will be executed to send and receive data between the ground
  /// station and satellite during the time range.
  /// </summary>
  public static partial class StellarStationService
  {
    static readonly string __ServiceName = "stellarstation.api.v1.StellarStationService";

    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.ListPlansRequest> __Marshaller_stellarstation_api_v1_ListPlansRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.ListPlansRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.ListPlansResponse> __Marshaller_stellarstation_api_v1_ListPlansResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.ListPlansResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.CancelPlanRequest> __Marshaller_stellarstation_api_v1_CancelPlanRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.CancelPlanRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.CancelPlanResponse> __Marshaller_stellarstation_api_v1_CancelPlanResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.CancelPlanResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest> __Marshaller_stellarstation_api_v1_ListUpcomingAvailablePassesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse> __Marshaller_stellarstation_api_v1_ListUpcomingAvailablePassesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.SatelliteStreamRequest> __Marshaller_stellarstation_api_v1_SatelliteStreamRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.SatelliteStreamRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.SatelliteStreamResponse> __Marshaller_stellarstation_api_v1_SatelliteStreamResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.SatelliteStreamResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.ReservePassRequest> __Marshaller_stellarstation_api_v1_ReservePassRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.ReservePassRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.ReservePassResponse> __Marshaller_stellarstation_api_v1_ReservePassResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.ReservePassResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.AddTleRequest> __Marshaller_stellarstation_api_v1_AddTleRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.AddTleRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.AddTleResponse> __Marshaller_stellarstation_api_v1_AddTleResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.AddTleResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.GetTleRequest> __Marshaller_stellarstation_api_v1_GetTleRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.GetTleRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.GetTleResponse> __Marshaller_stellarstation_api_v1_GetTleResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.GetTleResponse.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.SetTleSourceRequest> __Marshaller_stellarstation_api_v1_SetTleSourceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.SetTleSourceRequest.Parser));
    static readonly grpc::Marshaller<global::Stellarstation.Api.V1.SetTleSourceResponse> __Marshaller_stellarstation_api_v1_SetTleSourceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Stellarstation.Api.V1.SetTleSourceResponse.Parser));

    static readonly grpc::Method<global::Stellarstation.Api.V1.ListPlansRequest, global::Stellarstation.Api.V1.ListPlansResponse> __Method_ListPlans = new grpc::Method<global::Stellarstation.Api.V1.ListPlansRequest, global::Stellarstation.Api.V1.ListPlansResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListPlans",
        __Marshaller_stellarstation_api_v1_ListPlansRequest,
        __Marshaller_stellarstation_api_v1_ListPlansResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.CancelPlanRequest, global::Stellarstation.Api.V1.CancelPlanResponse> __Method_CancelPlan = new grpc::Method<global::Stellarstation.Api.V1.CancelPlanRequest, global::Stellarstation.Api.V1.CancelPlanResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CancelPlan",
        __Marshaller_stellarstation_api_v1_CancelPlanRequest,
        __Marshaller_stellarstation_api_v1_CancelPlanResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest, global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse> __Method_ListUpcomingAvailablePasses = new grpc::Method<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest, global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListUpcomingAvailablePasses",
        __Marshaller_stellarstation_api_v1_ListUpcomingAvailablePassesRequest,
        __Marshaller_stellarstation_api_v1_ListUpcomingAvailablePassesResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.SatelliteStreamRequest, global::Stellarstation.Api.V1.SatelliteStreamResponse> __Method_OpenSatelliteStream = new grpc::Method<global::Stellarstation.Api.V1.SatelliteStreamRequest, global::Stellarstation.Api.V1.SatelliteStreamResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "OpenSatelliteStream",
        __Marshaller_stellarstation_api_v1_SatelliteStreamRequest,
        __Marshaller_stellarstation_api_v1_SatelliteStreamResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.ReservePassRequest, global::Stellarstation.Api.V1.ReservePassResponse> __Method_ReservePass = new grpc::Method<global::Stellarstation.Api.V1.ReservePassRequest, global::Stellarstation.Api.V1.ReservePassResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ReservePass",
        __Marshaller_stellarstation_api_v1_ReservePassRequest,
        __Marshaller_stellarstation_api_v1_ReservePassResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.AddTleRequest, global::Stellarstation.Api.V1.AddTleResponse> __Method_AddTle = new grpc::Method<global::Stellarstation.Api.V1.AddTleRequest, global::Stellarstation.Api.V1.AddTleResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "AddTle",
        __Marshaller_stellarstation_api_v1_AddTleRequest,
        __Marshaller_stellarstation_api_v1_AddTleResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.GetTleRequest, global::Stellarstation.Api.V1.GetTleResponse> __Method_GetTle = new grpc::Method<global::Stellarstation.Api.V1.GetTleRequest, global::Stellarstation.Api.V1.GetTleResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetTle",
        __Marshaller_stellarstation_api_v1_GetTleRequest,
        __Marshaller_stellarstation_api_v1_GetTleResponse);

    static readonly grpc::Method<global::Stellarstation.Api.V1.SetTleSourceRequest, global::Stellarstation.Api.V1.SetTleSourceResponse> __Method_SetTleSource = new grpc::Method<global::Stellarstation.Api.V1.SetTleSourceRequest, global::Stellarstation.Api.V1.SetTleSourceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetTleSource",
        __Marshaller_stellarstation_api_v1_SetTleSourceRequest,
        __Marshaller_stellarstation_api_v1_SetTleSourceResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Stellarstation.Api.V1.StellarstationReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of StellarStationService</summary>
    [grpc::BindServiceMethod(typeof(StellarStationService), "BindService")]
    public abstract partial class StellarStationServiceBase
    {
      /// <summary>
      /// Lists the plans for a particular satellite.
      ///
      /// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
      /// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
      /// 31 days.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.ListPlansResponse> ListPlans(global::Stellarstation.Api.V1.ListPlansRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
      /// executed. This action cannot be undone, but it is still possible to reserve the corresponding
      /// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
      /// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
      /// AOS.
      ///
      /// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
      /// for details.
      ///
      /// If the plan is not found, the request will return a `NOT_FOUND` error.
      ///
      /// If the plan has already been canceled or is less than ten minutes away from its AOS, the
      /// request will return a `FAILED_PRECONDITION` error.
      ///
      /// If the plan is ongoing or has already finished executing, the request will return a
      /// `OUT_OF_RANGE` error.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.CancelPlanResponse> CancelPlan(global::Stellarstation.Api.V1.CancelPlanRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
      /// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
      /// reserve passes in any way - it is possible for a pass that is returned by this method to be
      /// unschedulable when actually trying to schedule because a conflict appeared during that time.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse> ListUpcomingAvailablePasses(global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
      /// client to send commands to the satellite and data received from the satellite will be returned
      /// as it is made available. All telemetry received from the satellite on reserved passes along
      /// with associated events from this point on will be returned as soon as this method is called. If
      /// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
      /// stream will be returned as well.
      ///
      /// The first `SatelliteStreamRequest` sent on the stream is used for configuring the stream.
      /// Unless otherwise specified, all configuration is taken from the first request and configuration
      /// values in subsequent requests will be ignored.
      ///
      /// The stream can be left open for any amount of time and telemetry will be received as available
      /// and returned. When the client is done with the stream, it should close it successfully. If the
      /// stream is cancelled with an unexpected error at any point, telemetry received before the next
      /// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
      /// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
      /// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
      /// with a `ABORTED` error.
      ///
      /// If the satellite is not found or the client is not authorized for it, the stream will be closed
      /// with a `NOT_FOUND` error.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task OpenSatelliteStream(grpc::IAsyncStreamReader<global::Stellarstation.Api.V1.SatelliteStreamRequest> requestStream, grpc::IServerStreamWriter<global::Stellarstation.Api.V1.SatelliteStreamResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Reserves a pass for later execution as a plan. The pass must be specified by a
      /// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
      /// `aos_time` must be at least one hour in the future.
      ///
      /// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
      ///
      /// If the requested pass cannot be scheduled due to a conflict with existing plans or other
      /// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
      /// if the pass `aos_time` is less than one hour in the future.
      ///
      /// Note that the reservation_token may have become unreservable since it was fetched. If that's
      /// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
      /// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
      /// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.ReservePassResponse> ReservePass(global::Stellarstation.Api.V1.ReservePassRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Adds TLE for a satellite.
      ///
      /// The TLE will be used for satellite orbit calculation until it is superseded by a newly
      /// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
      /// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
      ///
      /// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
      /// - the TLE cannot be parsed
      /// - the TLE norad ID does not correspond to the requested satellite.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.AddTleResponse> AddTle(global::Stellarstation.Api.V1.AddTleRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Gets the TLE for a satellite.
      ///
      /// The returned TLE will be the one that has most recently been added to StellarStation and matches
      /// the satellite's TLE source. This TLE is used when calculating satellite orbits.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.GetTleResponse> GetTle(global::Stellarstation.Api.V1.GetTleRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// An 'INVALID_ARGUMENT' error will be returned in the following condition:
      /// - no satellite_id is provided.
      /// - the source provided is invalid.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Stellarstation.Api.V1.SetTleSourceResponse> SetTleSource(global::Stellarstation.Api.V1.SetTleSourceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for StellarStationService</summary>
    public partial class StellarStationServiceClient : grpc::ClientBase<StellarStationServiceClient>
    {
      /// <summary>Creates a new client for StellarStationService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public StellarStationServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for StellarStationService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public StellarStationServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected StellarStationServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected StellarStationServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// Lists the plans for a particular satellite.
      ///
      /// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
      /// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
      /// 31 days.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.ListPlansResponse ListPlans(global::Stellarstation.Api.V1.ListPlansRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPlans(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Lists the plans for a particular satellite.
      ///
      /// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
      /// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
      /// 31 days.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.ListPlansResponse ListPlans(global::Stellarstation.Api.V1.ListPlansRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListPlans, null, options, request);
      }
      /// <summary>
      /// Lists the plans for a particular satellite.
      ///
      /// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
      /// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
      /// 31 days.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.ListPlansResponse> ListPlansAsync(global::Stellarstation.Api.V1.ListPlansRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPlansAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Lists the plans for a particular satellite.
      ///
      /// The request will be closed with an `INVALID_ARGUMENT` status if `satellite_id`,
      /// `aos_after`, or `aos_before` are missing, or the duration between the two times is longer than
      /// 31 days.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.ListPlansResponse> ListPlansAsync(global::Stellarstation.Api.V1.ListPlansRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListPlans, null, options, request);
      }
      /// <summary>
      /// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
      /// executed. This action cannot be undone, but it is still possible to reserve the corresponding
      /// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
      /// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
      /// AOS.
      ///
      /// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
      /// for details.
      ///
      /// If the plan is not found, the request will return a `NOT_FOUND` error.
      ///
      /// If the plan has already been canceled or is less than ten minutes away from its AOS, the
      /// request will return a `FAILED_PRECONDITION` error.
      ///
      /// If the plan is ongoing or has already finished executing, the request will return a
      /// `OUT_OF_RANGE` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.CancelPlanResponse CancelPlan(global::Stellarstation.Api.V1.CancelPlanRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelPlan(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
      /// executed. This action cannot be undone, but it is still possible to reserve the corresponding
      /// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
      /// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
      /// AOS.
      ///
      /// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
      /// for details.
      ///
      /// If the plan is not found, the request will return a `NOT_FOUND` error.
      ///
      /// If the plan has already been canceled or is less than ten minutes away from its AOS, the
      /// request will return a `FAILED_PRECONDITION` error.
      ///
      /// If the plan is ongoing or has already finished executing, the request will return a
      /// `OUT_OF_RANGE` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.CancelPlanResponse CancelPlan(global::Stellarstation.Api.V1.CancelPlanRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CancelPlan, null, options, request);
      }
      /// <summary>
      /// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
      /// executed. This action cannot be undone, but it is still possible to reserve the corresponding
      /// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
      /// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
      /// AOS.
      ///
      /// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
      /// for details.
      ///
      /// If the plan is not found, the request will return a `NOT_FOUND` error.
      ///
      /// If the plan has already been canceled or is less than ten minutes away from its AOS, the
      /// request will return a `FAILED_PRECONDITION` error.
      ///
      /// If the plan is ongoing or has already finished executing, the request will return a
      /// `OUT_OF_RANGE` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.CancelPlanResponse> CancelPlanAsync(global::Stellarstation.Api.V1.CancelPlanRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelPlanAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Cancel a previously reserved upcoming plan. Cancelling the plan will cause it to not be
      /// executed. This action cannot be undone, but it is still possible to reserve the corresponding
      /// pass again by calling `ListUpcomingAvailablePasses` and `ReservePass` as usual - this will
      /// cause a new plan to be reserved. The plan cannot be cancelled less than ten minutes before
      /// AOS.
      ///
      /// Canceling a plan may incur a charge based on the time left to AOS. See our cancellation policy
      /// for details.
      ///
      /// If the plan is not found, the request will return a `NOT_FOUND` error.
      ///
      /// If the plan has already been canceled or is less than ten minutes away from its AOS, the
      /// request will return a `FAILED_PRECONDITION` error.
      ///
      /// If the plan is ongoing or has already finished executing, the request will return a
      /// `OUT_OF_RANGE` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.CancelPlanResponse> CancelPlanAsync(global::Stellarstation.Api.V1.CancelPlanRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CancelPlan, null, options, request);
      }
      /// <summary>
      /// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
      /// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
      /// reserve passes in any way - it is possible for a pass that is returned by this method to be
      /// unschedulable when actually trying to schedule because a conflict appeared during that time.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse ListUpcomingAvailablePasses(global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListUpcomingAvailablePasses(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
      /// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
      /// reserve passes in any way - it is possible for a pass that is returned by this method to be
      /// unschedulable when actually trying to schedule because a conflict appeared during that time.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse ListUpcomingAvailablePasses(global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListUpcomingAvailablePasses, null, options, request);
      }
      /// <summary>
      /// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
      /// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
      /// reserve passes in any way - it is possible for a pass that is returned by this method to be
      /// unschedulable when actually trying to schedule because a conflict appeared during that time.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse> ListUpcomingAvailablePassesAsync(global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListUpcomingAvailablePassesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
      /// Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
      /// reserve passes in any way - it is possible for a pass that is returned by this method to be
      /// unschedulable when actually trying to schedule because a conflict appeared during that time.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse> ListUpcomingAvailablePassesAsync(global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListUpcomingAvailablePasses, null, options, request);
      }
      /// <summary>
      /// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
      /// client to send commands to the satellite and data received from the satellite will be returned
      /// as it is made available. All telemetry received from the satellite on reserved passes along
      /// with associated events from this point on will be returned as soon as this method is called. If
      /// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
      /// stream will be returned as well.
      ///
      /// The first `SatelliteStreamRequest` sent on the stream is used for configuring the stream.
      /// Unless otherwise specified, all configuration is taken from the first request and configuration
      /// values in subsequent requests will be ignored.
      ///
      /// The stream can be left open for any amount of time and telemetry will be received as available
      /// and returned. When the client is done with the stream, it should close it successfully. If the
      /// stream is cancelled with an unexpected error at any point, telemetry received before the next
      /// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
      /// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
      /// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
      /// with a `ABORTED` error.
      ///
      /// If the satellite is not found or the client is not authorized for it, the stream will be closed
      /// with a `NOT_FOUND` error.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Stellarstation.Api.V1.SatelliteStreamRequest, global::Stellarstation.Api.V1.SatelliteStreamResponse> OpenSatelliteStream(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OpenSatelliteStream(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
      /// client to send commands to the satellite and data received from the satellite will be returned
      /// as it is made available. All telemetry received from the satellite on reserved passes along
      /// with associated events from this point on will be returned as soon as this method is called. If
      /// `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
      /// stream will be returned as well.
      ///
      /// The first `SatelliteStreamRequest` sent on the stream is used for configuring the stream.
      /// Unless otherwise specified, all configuration is taken from the first request and configuration
      /// values in subsequent requests will be ignored.
      ///
      /// The stream can be left open for any amount of time and telemetry will be received as available
      /// and returned. When the client is done with the stream, it should close it successfully. If the
      /// stream is cancelled with an unexpected error at any point, telemetry received before the next
      /// call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
      /// call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
      /// expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
      /// with a `ABORTED` error.
      ///
      /// If the satellite is not found or the client is not authorized for it, the stream will be closed
      /// with a `NOT_FOUND` error.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Stellarstation.Api.V1.SatelliteStreamRequest, global::Stellarstation.Api.V1.SatelliteStreamResponse> OpenSatelliteStream(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_OpenSatelliteStream, null, options);
      }
      /// <summary>
      /// Reserves a pass for later execution as a plan. The pass must be specified by a
      /// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
      /// `aos_time` must be at least one hour in the future.
      ///
      /// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
      ///
      /// If the requested pass cannot be scheduled due to a conflict with existing plans or other
      /// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
      /// if the pass `aos_time` is less than one hour in the future.
      ///
      /// Note that the reservation_token may have become unreservable since it was fetched. If that's
      /// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
      /// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
      /// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.ReservePassResponse ReservePass(global::Stellarstation.Api.V1.ReservePassRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReservePass(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Reserves a pass for later execution as a plan. The pass must be specified by a
      /// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
      /// `aos_time` must be at least one hour in the future.
      ///
      /// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
      ///
      /// If the requested pass cannot be scheduled due to a conflict with existing plans or other
      /// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
      /// if the pass `aos_time` is less than one hour in the future.
      ///
      /// Note that the reservation_token may have become unreservable since it was fetched. If that's
      /// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
      /// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
      /// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.ReservePassResponse ReservePass(global::Stellarstation.Api.V1.ReservePassRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ReservePass, null, options, request);
      }
      /// <summary>
      /// Reserves a pass for later execution as a plan. The pass must be specified by a
      /// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
      /// `aos_time` must be at least one hour in the future.
      ///
      /// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
      ///
      /// If the requested pass cannot be scheduled due to a conflict with existing plans or other
      /// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
      /// if the pass `aos_time` is less than one hour in the future.
      ///
      /// Note that the reservation_token may have become unreservable since it was fetched. If that's
      /// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
      /// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
      /// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.ReservePassResponse> ReservePassAsync(global::Stellarstation.Api.V1.ReservePassRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ReservePassAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Reserves a pass for later execution as a plan. The pass must be specified by a
      /// `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
      /// `aos_time` must be at least one hour in the future.
      ///
      /// If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
      ///
      /// If the requested pass cannot be scheduled due to a conflict with existing plans or other
      /// scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
      /// if the pass `aos_time` is less than one hour in the future.
      ///
      /// Note that the reservation_token may have become unreservable since it was fetched. If that's
      /// the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
      /// `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
      /// The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.ReservePassResponse> ReservePassAsync(global::Stellarstation.Api.V1.ReservePassRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ReservePass, null, options, request);
      }
      /// <summary>
      /// Adds TLE for a satellite.
      ///
      /// The TLE will be used for satellite orbit calculation until it is superseded by a newly
      /// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
      /// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
      ///
      /// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
      /// - the TLE cannot be parsed
      /// - the TLE norad ID does not correspond to the requested satellite.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.AddTleResponse AddTle(global::Stellarstation.Api.V1.AddTleRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddTle(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Adds TLE for a satellite.
      ///
      /// The TLE will be used for satellite orbit calculation until it is superseded by a newly
      /// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
      /// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
      ///
      /// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
      /// - the TLE cannot be parsed
      /// - the TLE norad ID does not correspond to the requested satellite.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.AddTleResponse AddTle(global::Stellarstation.Api.V1.AddTleRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_AddTle, null, options, request);
      }
      /// <summary>
      /// Adds TLE for a satellite.
      ///
      /// The TLE will be used for satellite orbit calculation until it is superseded by a newly
      /// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
      /// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
      ///
      /// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
      /// - the TLE cannot be parsed
      /// - the TLE norad ID does not correspond to the requested satellite.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.AddTleResponse> AddTleAsync(global::Stellarstation.Api.V1.AddTleRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddTleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Adds TLE for a satellite.
      ///
      /// The TLE will be used for satellite orbit calculation until it is superseded by a newly
      /// added TLE. Adding TLE using this API will automatically change the satellite's TLE source to
      /// `MANUAL` if it was previously set to `NORAD` to allow for immediate use.
      ///
      /// An 'INVALID_ARGUMENT' error will be returned in the following conditions:
      /// - the TLE cannot be parsed
      /// - the TLE norad ID does not correspond to the requested satellite.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.AddTleResponse> AddTleAsync(global::Stellarstation.Api.V1.AddTleRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_AddTle, null, options, request);
      }
      /// <summary>
      /// Gets the TLE for a satellite.
      ///
      /// The returned TLE will be the one that has most recently been added to StellarStation and matches
      /// the satellite's TLE source. This TLE is used when calculating satellite orbits.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.GetTleResponse GetTle(global::Stellarstation.Api.V1.GetTleRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTle(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Gets the TLE for a satellite.
      ///
      /// The returned TLE will be the one that has most recently been added to StellarStation and matches
      /// the satellite's TLE source. This TLE is used when calculating satellite orbits.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.GetTleResponse GetTle(global::Stellarstation.Api.V1.GetTleRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetTle, null, options, request);
      }
      /// <summary>
      /// Gets the TLE for a satellite.
      ///
      /// The returned TLE will be the one that has most recently been added to StellarStation and matches
      /// the satellite's TLE source. This TLE is used when calculating satellite orbits.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.GetTleResponse> GetTleAsync(global::Stellarstation.Api.V1.GetTleRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Gets the TLE for a satellite.
      ///
      /// The returned TLE will be the one that has most recently been added to StellarStation and matches
      /// the satellite's TLE source. This TLE is used when calculating satellite orbits.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.GetTleResponse> GetTleAsync(global::Stellarstation.Api.V1.GetTleRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetTle, null, options, request);
      }
      /// <summary>
      /// An 'INVALID_ARGUMENT' error will be returned in the following condition:
      /// - no satellite_id is provided.
      /// - the source provided is invalid.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.SetTleSourceResponse SetTleSource(global::Stellarstation.Api.V1.SetTleSourceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetTleSource(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// An 'INVALID_ARGUMENT' error will be returned in the following condition:
      /// - no satellite_id is provided.
      /// - the source provided is invalid.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Stellarstation.Api.V1.SetTleSourceResponse SetTleSource(global::Stellarstation.Api.V1.SetTleSourceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetTleSource, null, options, request);
      }
      /// <summary>
      /// An 'INVALID_ARGUMENT' error will be returned in the following condition:
      /// - no satellite_id is provided.
      /// - the source provided is invalid.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.SetTleSourceResponse> SetTleSourceAsync(global::Stellarstation.Api.V1.SetTleSourceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetTleSourceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// An 'INVALID_ARGUMENT' error will be returned in the following condition:
      /// - no satellite_id is provided.
      /// - the source provided is invalid.
      ///
      /// If the satellite is not found or the client is not authorized for it, the request will return
      /// a `NOT_FOUND` error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Stellarstation.Api.V1.SetTleSourceResponse> SetTleSourceAsync(global::Stellarstation.Api.V1.SetTleSourceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetTleSource, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override StellarStationServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new StellarStationServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(StellarStationServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_ListPlans, serviceImpl.ListPlans)
          .AddMethod(__Method_CancelPlan, serviceImpl.CancelPlan)
          .AddMethod(__Method_ListUpcomingAvailablePasses, serviceImpl.ListUpcomingAvailablePasses)
          .AddMethod(__Method_OpenSatelliteStream, serviceImpl.OpenSatelliteStream)
          .AddMethod(__Method_ReservePass, serviceImpl.ReservePass)
          .AddMethod(__Method_AddTle, serviceImpl.AddTle)
          .AddMethod(__Method_GetTle, serviceImpl.GetTle)
          .AddMethod(__Method_SetTleSource, serviceImpl.SetTleSource).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the  service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, StellarStationServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_ListPlans, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.ListPlansRequest, global::Stellarstation.Api.V1.ListPlansResponse>(serviceImpl.ListPlans));
      serviceBinder.AddMethod(__Method_CancelPlan, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.CancelPlanRequest, global::Stellarstation.Api.V1.CancelPlanResponse>(serviceImpl.CancelPlan));
      serviceBinder.AddMethod(__Method_ListUpcomingAvailablePasses, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.ListUpcomingAvailablePassesRequest, global::Stellarstation.Api.V1.ListUpcomingAvailablePassesResponse>(serviceImpl.ListUpcomingAvailablePasses));
      serviceBinder.AddMethod(__Method_OpenSatelliteStream, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::Stellarstation.Api.V1.SatelliteStreamRequest, global::Stellarstation.Api.V1.SatelliteStreamResponse>(serviceImpl.OpenSatelliteStream));
      serviceBinder.AddMethod(__Method_ReservePass, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.ReservePassRequest, global::Stellarstation.Api.V1.ReservePassResponse>(serviceImpl.ReservePass));
      serviceBinder.AddMethod(__Method_AddTle, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.AddTleRequest, global::Stellarstation.Api.V1.AddTleResponse>(serviceImpl.AddTle));
      serviceBinder.AddMethod(__Method_GetTle, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.GetTleRequest, global::Stellarstation.Api.V1.GetTleResponse>(serviceImpl.GetTle));
      serviceBinder.AddMethod(__Method_SetTleSource, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Stellarstation.Api.V1.SetTleSourceRequest, global::Stellarstation.Api.V1.SetTleSourceResponse>(serviceImpl.SetTleSource));
    }

  }
}
#endregion
